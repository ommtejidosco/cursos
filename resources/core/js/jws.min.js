(()=>{"use strict";const e=crypto,t=e=>e instanceof CryptoKey,r=new TextEncoder,n=new TextDecoder;function a(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;return e.forEach((e=>{r.set(e,n),n+=e.length})),r}const o=e=>{let t=e;"string"==typeof t&&(t=r.encode(t));const n=[];for(let e=0;e<t.length;e+=32768)n.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(n.join(""))},s=e=>o(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),i=e=>{let t=e;t instanceof Uint8Array&&(t=n.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class c extends Error{constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class d extends c{constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}}class u extends c{constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}static get code(){return"ERR_JWT_EXPIRED"}}class l extends c{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class p extends c{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class h extends c{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class f extends c{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class y extends c{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}e.getRandomValues.bind(e);const w=e=>t(e),m=["CryptoKey"];function S(){return"undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime}function E(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const g=(e,...t)=>E("Key must be ",e,...t);function b(e,t,...r){return E(`Key for the ${e} algorithm must be `,t,...r)}const A=async(r,n,a)=>{if(!t(a))throw new TypeError(g(a,...m));if(!a.extractable)throw new TypeError("CryptoKey is not extractable");if(a.type!==r)throw new TypeError(`key is not a ${r} key`);return s=o(new Uint8Array(await e.subtle.exportKey(n,a))),`-----BEGIN ${i=`${r.toUpperCase()} KEY`}-----\n${(s.match(/.{1,64}/g)||[]).join("\n")}\n-----END ${i}-----`;var s,i},v=(e,t,r=0)=>{0===r&&(t.unshift(t.length),t.unshift(6));let n=e.indexOf(t[0],r);if(-1===n)return!1;const a=e.subarray(n,n+t.length);return a.length===t.length&&(a.every(((e,r)=>e===t[r]))||v(e,t,n+1))},P=e=>{switch(!0){case v(e,[42,134,72,206,61,3,1,7]):return"P-256";case v(e,[43,129,4,0,34]):return"P-384";case v(e,[43,129,4,0,35]):return"P-521";case v(e,[43,101,110]):return"X25519";case v(e,[43,101,111]):return"X448";case v(e,[43,101,112]):return"Ed25519";case v(e,[43,101,113]):return"Ed448";default:throw new p("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},R=async(t,r,n,a,o)=>{var s;let i,c;const d=new Uint8Array(atob(n.replace(t,"")).split("").map((e=>e.charCodeAt(0)))),u="spki"===r;switch(a){case"PS256":case"PS384":case"PS512":i={name:"RSA-PSS",hash:`SHA-${a.slice(-3)}`},c=u?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":i={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${a.slice(-3)}`},c=u?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":i={name:"RSA-OAEP",hash:`SHA-${parseInt(a.slice(-3),10)||1}`},c=u?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":i={name:"ECDSA",namedCurve:"P-256"},c=u?["verify"]:["sign"];break;case"ES384":i={name:"ECDSA",namedCurve:"P-384"},c=u?["verify"]:["sign"];break;case"ES512":i={name:"ECDSA",namedCurve:"P-521"},c=u?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const e=P(d);i=e.startsWith("P-")?{name:"ECDH",namedCurve:e}:{name:e},c=u?[]:["deriveBits"];break}case S()&&"EdDSA":{const e=P(d).toUpperCase();i={name:`NODE-${e}`,namedCurve:`NODE-${e}`},c=u?["verify"]:["sign"];break}case"EdDSA":i={name:P(d)},c=u?["verify"]:["sign"];break;default:throw new p('Invalid or unsupported "alg" (Algorithm) value')}return e.subtle.importKey(r,d,i,null!==(s=null==o?void 0:o.extractable)&&void 0!==s&&s,c)};const H=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!w(t))throw new TypeError(b(e,t,...m,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${m.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!w(t))throw new TypeError(b(e,t,...m));if("secret"===t.type)throw new TypeError(`${m.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${m.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${m.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${m.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${m.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)},C=function(e,t,r,n,a){if(void 0!==a.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!o.has(t))throw new p(`Extension Header Parameter "${t}" is not recognized`);if(void 0===a[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)};async function k(e){return(e=>A("public","spki",e))(e)}async function _(e){return(e=>A("private","pkcs8",e))(e)}function I(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case S()&&"EdDSA":const{namedCurve:n}=t;return{name:n,namedCurve:n};case"EdDSA":return{name:t.name};default:throw new p(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}Symbol();const T=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function D(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function O(e,t){return e.name===t}function K(e){return parseInt(e.name.slice(4),10)}function J(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!O(e.algorithm,"HMAC"))throw D("HMAC");const r=parseInt(t.slice(2),10);if(K(e.algorithm.hash)!==r)throw D(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!O(e.algorithm,"RSASSA-PKCS1-v1_5"))throw D("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(K(e.algorithm.hash)!==r)throw D(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!O(e.algorithm,"RSA-PSS"))throw D("RSA-PSS");const r=parseInt(t.slice(2),10);if(K(e.algorithm.hash)!==r)throw D(`SHA-${r}`,"algorithm.hash");break}case S()&&"EdDSA":if(!O(e.algorithm,"NODE-ED25519"))throw D("NODE-ED25519");break;case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw D("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!O(e.algorithm,"ECDSA"))throw D("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw D(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}!function(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}(e,r)}function W(r,n,a){if(t(n))return J(n,r,a),n;if(n instanceof Uint8Array){if(!r.startsWith("HS"))throw new TypeError(g(n,...m));return e.subtle.importKey("raw",n,{hash:`SHA-${r.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(g(n,...m,"Uint8Array"))}const x=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function U(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}async function $(t,o,s){if(t instanceof Uint8Array&&(t=n.decode(t)),"string"!=typeof t)throw new h("Compact JWS must be a string or Uint8Array");const{0:c,1:d,2:u,length:p}=t.split(".");if(3!==p)throw new h("Invalid Compact JWS");const f=await async function(t,o,s){var c;if(!U(t))throw new h("Flattened JWS must be an object");if(void 0===t.protected&&void 0===t.header)throw new h('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==t.protected&&"string"!=typeof t.protected)throw new h("JWS Protected Header incorrect type");if(void 0===t.payload)throw new h("JWS Payload missing");if("string"!=typeof t.signature)throw new h("JWS Signature missing or incorrect type");if(void 0!==t.header&&!U(t.header))throw new h("JWS Unprotected Header incorrect type");let d={};if(t.protected)try{const e=i(t.protected);d=JSON.parse(n.decode(e))}catch(e){throw new h("JWS Protected Header is invalid")}if(!x(d,t.header))throw new h("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const u={...d,...t.header};let p=!0;if(C(h,new Map([["b64",!0]]),null==s?void 0:s.crit,d,u).has("b64")&&(p=d.b64,"boolean"!=typeof p))throw new h('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:f}=u;if("string"!=typeof f||!f)throw new h('JWS "alg" (Algorithm) Header Parameter missing or invalid');const w=s&&((e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)})("algorithms",s.algorithms);if(w&&!w.has(f))throw new l('"alg" (Algorithm) Header Parameter not allowed');if(p){if("string"!=typeof t.payload)throw new h("JWS Payload must be a string")}else if("string"!=typeof t.payload&&!(t.payload instanceof Uint8Array))throw new h("JWS Payload must be a string or an Uint8Array instance");let m=!1;"function"==typeof o&&(o=await o(d,t),m=!0),H(f,o,"verify");const S=a(r.encode(null!==(c=t.protected)&&void 0!==c?c:""),r.encode("."),"string"==typeof t.payload?r.encode(t.payload):t.payload),E=i(t.signature);if(!await(async(t,r,n,a)=>{const o=await W(t,r,"verify");T(t,o);const s=I(t,o.algorithm);try{return await e.subtle.verify(s,o,n,a)}catch(e){return!1}})(f,o,E,S))throw new y;let g;g=p?i(t.payload):"string"==typeof t.payload?r.encode(t.payload):t.payload;const b={payload:g};return void 0!==t.protected&&(b.protectedHeader=d),void 0!==t.header&&(b.unprotectedHeader=t.header),m?{...b,key:o}:b}({payload:d,protected:c,signature:u},o,s),w={payload:f.payload,protectedHeader:f.protectedHeader};return"function"==typeof o?{...w,key:f.key}:w}const N=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,L=e=>{const t=N.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(86400*r);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}},M=e=>e.toLowerCase().replace(/^application\//,""),j=(e,t,r={})=>{const{typ:a}=r;if(a&&("string"!=typeof e.typ||M(e.typ)!==M(a)))throw new d('unexpected "typ" JWT header value',"typ","check_failed");let o;try{o=JSON.parse(n.decode(t))}catch(e){}if(!U(o))throw new f("JWT Claims Set must be a top-level JSON object");const{issuer:s}=r;if(s&&!(Array.isArray(s)?s:[s]).includes(o.iss))throw new d('unexpected "iss" claim value',"iss","check_failed");const{subject:i}=r;if(i&&o.sub!==i)throw new d('unexpected "sub" claim value',"sub","check_failed");const{audience:c}=r;if(c&&(p="string"==typeof c?[c]:c,!("string"==typeof(l=o.aud)?p.includes(l):Array.isArray(l)&&p.some(Set.prototype.has.bind(new Set(l))))))throw new d('unexpected "aud" claim value',"aud","check_failed");var l,p;let h;switch(typeof r.clockTolerance){case"string":h=L(r.clockTolerance);break;case"number":h=r.clockTolerance;break;case"undefined":h=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:y}=r,w=(m=y||new Date,Math.floor(m.getTime()/1e3));var m;if((void 0!==o.iat||r.maxTokenAge)&&"number"!=typeof o.iat)throw new d('"iat" claim must be a number',"iat","invalid");if(void 0!==o.nbf){if("number"!=typeof o.nbf)throw new d('"nbf" claim must be a number',"nbf","invalid");if(o.nbf>w+h)throw new d('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==o.exp){if("number"!=typeof o.exp)throw new d('"exp" claim must be a number',"exp","invalid");if(o.exp<=w-h)throw new u('"exp" claim timestamp check failed',"exp","check_failed")}if(r.maxTokenAge){const e=w-o.iat;if(e-h>("number"==typeof r.maxTokenAge?r.maxTokenAge:L(r.maxTokenAge)))throw new u('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-h)throw new d('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return o};class B{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(t,o){if(!this._protectedHeader&&!this._unprotectedHeader)throw new h("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!x(this._protectedHeader,this._unprotectedHeader))throw new h("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader};let c=!0;if(C(h,new Map([["b64",!0]]),null==o?void 0:o.crit,this._protectedHeader,i).has("b64")&&(c=this._protectedHeader.b64,"boolean"!=typeof c))throw new h('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:d}=i;if("string"!=typeof d||!d)throw new h('JWS "alg" (Algorithm) Header Parameter missing or invalid');H(d,t,"sign");let u,l=this._payload;c&&(l=r.encode(s(l))),u=this._protectedHeader?r.encode(s(JSON.stringify(this._protectedHeader))):r.encode("");const p=a(u,r.encode("."),l),f=await(async(t,r,n)=>{const a=await W(t,r,"sign");T(t,a);const o=await e.subtle.sign(I(t,a.algorithm),a,n);return new Uint8Array(o)})(d,t,p),y={signature:s(f),payload:""};return c&&(y.payload=n.decode(l)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=n.decode(u)),y}}function V(e){var t;const r=null!==(t=null==e?void 0:e.modulusLength)&&void 0!==t?t:2048;if("number"!=typeof r||r<2048)throw new p("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return r}async function G(e,t){return async function(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN PUBLIC KEY-----"))throw new TypeError('"spki" must be SPKI formatted string');return((e,t,r)=>R(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r))(e,t,r)}(e,t)}async function X(e,t){return await async function(e,t,r){var n;const a=await $(e,t,r);if((null===(n=a.protectedHeader.crit)||void 0===n?void 0:n.includes("b64"))&&!1===a.protectedHeader.b64)throw new f("JWTs MUST NOT use unencoded payload");const o={payload:j(a.protectedHeader,a.payload,r),protectedHeader:a.protectedHeader};return"function"==typeof t?{...o,key:a.key}:o}(e,t)}window.serverPublicKey="-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvEKUPvO9FYdeQKIdfsQz\n7HNWCUA6sczWKL6Xh0z8He66ogsVNM/9wlEnyJ6BOXqgq7DjPg0ND0tIDwRD/k2f\nf3IO3NMz3ToQz36U1UuGOM3E5V/0ZcmwJApIoiAsJIHbbUkJxBxknTEknHmAqSVI\nQJjzHacyv+uEu1cm6iuDvJ4Z79aDoJTt5jMlLf8/zhu+r5oYz4UcaRBihxcKx5UM\nLoEDIamoQ22oUEJRdJBfJ/v7PFQMxhbNwy8nMgW3cICIWaKCjXwgPlwy6v5DhM4m\nJfCSq4huxmsUVNT/+OHcLgbqukb06tVCWzE9f+NDqXHmJ0EAyVIX24LLXO7vTPnX\nMwIDAQAB\n-----END PUBLIC KEY-----",window.verify=X,window.verifyResponse=async function(e){return X(e,await G(window.serverPublicKey,"RS256"))},window.generateKeyPair=async function(t){const{publicKey:r,privateKey:n}=await async function(t,r){return async function(t,r){var n,a,o;let s,i;switch(t){case"PS256":case"PS384":case"PS512":s={name:"RSA-PSS",hash:`SHA-${t.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:V(r)},i=["sign","verify"];break;case"RS256":case"RS384":case"RS512":s={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${t.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:V(r)},i=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s={name:"RSA-OAEP",hash:`SHA-${parseInt(t.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:V(r)},i=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":s={name:"ECDSA",namedCurve:"P-256"},i=["sign","verify"];break;case"ES384":s={name:"ECDSA",namedCurve:"P-384"},i=["sign","verify"];break;case"ES512":s={name:"ECDSA",namedCurve:"P-521"},i=["sign","verify"];break;case S()&&"EdDSA":switch(null==r?void 0:r.crv){case void 0:case"Ed25519":s={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},i=["sign","verify"];break;default:throw new p("Invalid or unsupported crv option provided")}break;case"EdDSA":i=["sign","verify"];const e=null!==(n=null==r?void 0:r.crv)&&void 0!==n?n:"Ed25519";switch(e){case"Ed25519":case"Ed448":s={name:e};break;default:throw new p("Invalid or unsupported crv option provided")}break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{i=["deriveKey","deriveBits"];const e=null!==(a=null==r?void 0:r.crv)&&void 0!==a?a:"P-256";switch(e){case"P-256":case"P-384":case"P-521":s={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":s={name:e};break;default:throw new p("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new p('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return e.subtle.generateKey(s,null!==(o=null==r?void 0:r.extractable)&&void 0!==o&&o,i)}(t,r)}("RS256",{extractable:!0});return localStorage.setItem(t,await _(n)),console.log(await _(n)),console.log(await k(r)),r},window.signMessage=async function(e,t){const r=await new B((new TextEncoder).encode(JSON.stringify(e))).setProtectedHeader({alg:"RS256"}).sign(t);return r.protected+"."+r.payload+"."+r.signature},window.exportSPKI=async function(e){return k(e)},window.importPKCS8=async function(e,t){return async function(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN PRIVATE KEY-----"))throw new TypeError('"pkcs8" must be PCKS8 formatted string');return((e,t,r)=>R(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r))(e,t,r)}(e,t)},window.importSPKI=G})();